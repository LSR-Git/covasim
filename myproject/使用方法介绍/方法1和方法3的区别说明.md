# 方法1和方法3的区别说明

## 核心区别总结

| 特性 | 方法1 | 方法3 |
|------|-------|-------|
| **代码风格** | 过程式，直接编写 | 函数式+配置驱动 |
| **适用场景** | 简单场景，层数少 | 复杂场景，需要多次创建 |
| **代码复用** | 每次都要重写 | 函数可复用 |
| **灵活性** | 中等 | 高（通过配置字典） |
| **代码量** | 较多（重复代码多） | 较少（封装在函数中） |
| **可读性** | 直观，但冗长 | 简洁，但需要理解函数 |

## 详细对比

### 方法1：直接编写代码

**特点：**
- ✅ **直观易懂**：每一步都清晰可见
- ✅ **适合学习**：可以清楚看到每个层是如何创建的
- ❌ **代码重复**：每添加一个层都要写类似的代码
- ❌ **不易扩展**：添加新层需要修改多处代码

**代码示例：**
```python
# 方法1：直接编写，每一步都很清楚
contacts = cv.Contacts()

# 家庭层 - 手动创建
home_contacts = cv.make_microstructured_contacts(pop_size, cluster_size=3.0)
contacts.add_layer(home=cv.Layer(**home_contacts, label='home'))

# 办公室层 - 手动处理年龄筛选
work_ages = (ages >= 22) & (ages < 65)
work_indices = np.where(work_ages)[0]
office_contacts = cv.make_random_contacts(len(work_indices), n=15, mapping=work_indices)
contacts.add_layer(office=cv.Layer(**office_contacts, label='office'))

# 餐厅层 - 手动创建
restaurant_contacts = cv.make_random_contacts(pop_size, n=5)
contacts.add_layer(restaurant=cv.Layer(**restaurant_contacts, label='restaurant'))

# ... 每添加一个层都要写类似的代码
```

**适用场景：**
- 只有2-3个层
- 每个层的创建逻辑都不同
- 需要精确控制每一步
- 一次性使用，不需要复用

### 方法3：配置字典+辅助函数

**特点：**
- ✅ **代码简洁**：通过配置字典定义，函数自动处理
- ✅ **易于扩展**：添加新层只需在配置字典中添加一项
- ✅ **可复用**：函数可以用于创建不同配置的人口
- ✅ **统一处理**：年龄筛选、聚类结构等逻辑统一封装
- ❌ **需要理解函数**：需要先理解函数的工作原理

**代码示例：**
```python
# 方法3：通过配置字典定义，函数自动创建
def create_custom_population(pop_size, layer_config):
    # 函数内部封装了所有创建逻辑
    # 自动处理年龄筛选、聚类结构等
    ...

# 定义配置（简洁明了）
custom_config = {
    'family': {
        'cluster_size': 3.5,
        'age_range': None
    },
    'workplace': {
        'n_contacts': 20,
        'age_range': (22, 65)
    },
    'shopping': {
        'n_contacts': 10,
        'age_range': None
    }
}

# 一行代码创建所有层
popdict, layer_keys = create_custom_population(8000, custom_config)
```

**适用场景：**
- 有多个层（4个以上）
- 需要多次创建不同配置的人口
- 层的创建逻辑相似（都是年龄筛选+接触创建）
- 需要快速调整配置

## 具体差异示例

### 差异1：年龄筛选的处理

**方法1：** 每次都要手动写
```python
# 办公室层
work_ages = (ages >= 22) & (ages < 65)
work_indices = np.where(work_ages)[0]
office_contacts = cv.make_random_contacts(len(work_indices), n=15, mapping=work_indices)

# 健身房层 - 又要写一遍类似的代码
gym_ages = (ages >= 20) & (ages < 50)
gym_indices = np.where(gym_ages)[0]
gym_contacts = cv.make_random_contacts(len(gym_indices), n=8, mapping=gym_indices)
```

**方法3：** 函数自动处理
```python
# 配置中指定年龄范围，函数自动处理
custom_config = {
    'workplace': {
        'n_contacts': 20,
        'age_range': (22, 65)  # 函数内部自动筛选
    },
    'gym': {
        'n_contacts': 8,
        'age_range': (20, 50)  # 函数内部自动筛选
    }
}
```

### 差异2：添加新层

**方法1：** 需要添加多行代码
```python
# 添加新层 'school'
school_ages = (ages >= 6) & (ages < 22)
school_indices = np.where(school_ages)[0]
school_contacts = cv.make_random_contacts(len(school_indices), n=25, mapping=school_indices)
contacts.add_layer(school=cv.Layer(**school_contacts, label='school'))

# 还要更新 layer_keys
custom_layer_keys.append('school')

# 还要设置参数
sim['contacts']['school'] = 25
sim['beta_layer']['school'] = 0.7
# ... 等等
```

**方法3：** 只需在配置中添加一项
```python
# 只需在配置中添加
custom_config['school'] = {
    'n_contacts': 25,
    'age_range': (6, 22)
}

# 重新运行函数即可
popdict, layer_keys = create_custom_population(8000, custom_config)
```

### 差异3：代码复用

**方法1：** 每次都要重写
```python
# 创建第一个模拟
# ... 写50行代码创建人口

# 创建第二个模拟（不同配置）
# ... 又要写50行类似的代码
```

**方法3：** 复用函数
```python
# 创建第一个模拟
config1 = {...}
popdict1, keys1 = create_custom_population(8000, config1)

# 创建第二个模拟（只需改配置）
config2 = {...}  # 不同的配置
popdict2, keys2 = create_custom_population(10000, config2)
```

## 选择建议

### 选择方法1，如果：
- ✅ 只有2-3个层
- ✅ 每个层的创建逻辑差异很大
- ✅ 需要精确控制每一步
- ✅ 一次性使用，不需要复用
- ✅ 正在学习，想理解底层原理

### 选择方法3，如果：
- ✅ 有4个以上的层
- ✅ 需要多次创建不同配置的人口
- ✅ 层的创建逻辑相似（年龄筛选+接触创建）
- ✅ 需要快速调整和实验不同配置
- ✅ 代码需要维护和扩展

## 混合使用

你也可以结合两种方法：
- 用方法1创建特殊的、逻辑复杂的层
- 用方法3创建常规的、逻辑相似的层

```python
# 用方法3创建常规层
config = {
    'workplace': {...},
    'shopping': {...}
}
popdict, keys = create_custom_population(8000, config)

# 用方法1添加特殊层
special_contacts = create_special_layer(...)  # 特殊的创建逻辑
popdict['contacts'].add_layer(special=special_contacts)
```

## 总结

- **方法1** = 直接编写，直观但冗长，适合简单场景
- **方法3** = 配置驱动，简洁但抽象，适合复杂场景

选择哪个主要看你的需求：如果只是快速创建一个简单的人口，用方法1；如果需要创建多个不同配置的人口，用方法3。
